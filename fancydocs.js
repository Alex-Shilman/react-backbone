registerProject({"title":"react-backbone","summary":"Give [Backbone](#link/http%3A%2F%2Fbackbonejs.org%2F) awareness to your [React](#link/http%3A%2F%2Ffacebook.github.io%2Freact%2F) components and so much more.\n\nAll react-model bindings is accomplished using mixins.  The general concept is to provide very atomic mixins to do specific things that work well together.  Depending on the needs of your react component, you can include as many mixins as appropriate.\n\nThe general features of this project are\n\n* many mixins to force update components on model change events, be aware of XHR activity, model validation events and much more\n* add Backbone.View like declaritive events for [models](#link/%23project%2Fjhudson8%2Freact-backbone%2Fsnippet%2Fpackage%2Fmodel%2520events) and [collections](#link/%23project%2Fjhudson8%2Freact-backbone%2Fsnippet%2Fpackage%2Fcollection%2520events) to your React components\n* add [dependency management](#link/%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Freact-mixin-manager) to your React mixins for better reuse\n* provide low level Backbone.Model-aware [input components](#link/%23project%2Fjhudson8%2Freact-backbone%2Fapi%2FInput%2520Components)\n* add [managed event bindings](#link/%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Freact-events) which will clean up when the React component is unmounted\n* enhance available declarative events by adding [callback wrappers](#link/%23project%2Fjhudson8%2Freact-backbone%2Fapi%2FEvent%2520Binding%2520Definitions) like ```debounce```\n* enhance Backbone.sync to provide [rich XHR awareness](#link/%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Fbackbone-xhr-events) using Backbone Events\n\nSee the step-by-step [usage tutorials](#link/%23project%2Fjhudson8%2Freact-backbone%2Fsection%2FUsage%2520tutorials) to help get started.","dependantProjects":[{"id":"jhudson8/react-mixin-manager","url":"https://github.com/jhudson8/react-mixin-manager","description":""},{"id":"jhudson8/react-events","url":"https://github.com/jhudson8/react-events","description":""},{"id":"jhudson8/backbone-xhr-events","url":"https://github.com/jhudson8/backbone-xhr-events","description":"(optional)"}],"installation":"#### Browser:\n\n```\n    ... include backbone, underscore, react ...\n    <script src=\".../react-backbone-with-deps[-min].js\"></script>\n```\n\n#### CommonJS\n```\n    var React = require('react');\n    var _ = require('underscore');\n    var Backbone = require('backbone');\n\n    require('react-backbone/with-deps')(React, Backbone, _);\n```\n\n#### AMD\n```\n    require(\n      ['react', 'backbone', 'underscore', react-backbone/with-deps'],\n      function(React, Backbone, _, reactBackbone) {\n        reactBackbone(React, Backbone, _);\n    });\n```\n\n","sections":[{"body":"* [Handling model/collection changes and XHR loading indicators](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Freact-backbone%2Ftree%2Fmaster%2Ftutorials%2Fcollection-binding)\n* [Forms validation and input field binding](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Freact-backbone%2Ftree%2Fmaster%2Ftutorials%2Fforms)\n* [Using managed events and mixin dependencies to create a responsive component](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Freact-backbone%2Ftree%2Fmaster%2Ftutorials%2Fresponsive-design)\n* [Custom event handlers and event driven applications](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Freact-backbone%2Fblob%2Fmaster%2Ftutorials%2Fevent-driven-app)","title":"Usage tutorials","sections":[]},{"body":"If you are using [webpack](#link/http%3A%2F%2Fwebpack.github.io%2F) you can easily remove jquery from your app (assuming you don't need it for other purposes) by doing the following\n\npackage.json\n```\n  dependencies: {\n    // or some other $.ajax implementation\n    \"component-ajax\": \"0.0.2\",\n    \"exoskeleton\": \"^0.7.0\",\n    ...\n  }\n```\n\nwebpack.config.js (npm install https://github.com/webpack/imports-loader)\n```\n    plugins: [\n        new webpack.IgnorePlugin(/^jquery$/)\n    ],\n    loaders: [\n        { test: /exoskeleton\\.js$/,    loader: \"imports?define=>false\"}\n    ],\n    resolve: {\n      alias: {\n        backbone: 'exoskeleton/exoskeleton.js'\n      }\n    },\n```\n\nWhen initializing react-backbone\n```\nvar ajax = require('component-ajax');\nBackbone.ajax = function() {\n  return ajax.apply(this, arguments);\n};\n```","title":"Removing JQuery","sections":[]},{"body":"React components, by default, will have a single bound model and/or collection (using the ```model``` and ```collection``` properties).  This behavior can be altered by specifically providing the ```modelAware``` or ```collectionAware``` mixin with parameters representing the proerty names.\n\nThe ```modelAware```/```collectionAware``` mixin is not required if you want to have only a single model/collection bound using the ```model```/```collection``` property.","title":"Multiple models and collections","sections":[{"body":"If you wanted to have a component that use the ```foo``` property for component model bindings\n\n```javascript\n    React.createClass({\n      mixins: ['modelAware(\"foo\")', 'modelEvents'],\n      events: {\n        'model:bar': function() {\n          // this will be executed when the model assigned to the\n          // \"foo\" property triggers the \"bar\" event\n        }\n      }\n    });\n```","title":"Overriding the default model/collection keys","sections":[]},{"body":"Or, if you want to have 2 components (identified by the ```foo``` and ```bar``` property names) that, for example, you want to listen to change events on\n\n```javascript\n    React.createClass({\n      mixins: ['modelAware(\"foo\", \"bar\")', 'modelChangeAware'],\n      events: {\n        'model:theEvent': function() {\n          // this will be executed when the model assigned to the\n          // \"foo\" or \"bar\" property triggers the \"theEvent\" event\n        }\n      },\n      render: function() {\n        // this will be executed when the model assigned to the\n        // \"foo\" or \"bar\" property triggers the \"change\" event\n        // because of the \"modelChangeAware\" mixin\n      }\n    });\n```\n\nThe same functionality works with collection events as well.","title":"Multiple object bindings","sections":[]}]}],"api":{"Input Components":{"methods":{},"description":"Low level backbone model-aware input components are provided.  These will\n\n* provide an option for 2-way binding\n* set the correct value from the model if the *name* property matches the model attribute to be used\n* contribute to [modelPopulate](#link/%23snippet%2Fpackage%2FmodelPopulate)\n\nEach input component also has the following methods\n\n* ***getValue***: returns the input field value as it should be set on the model\n* ***getDOMValue***: returns the actual value attribute of the input field\n\nIn most cases, ```getValue``` and ```getDOMValue``` are the same.  But, for checkboxes, ```getValue``` will return an actual boolean representing whether the field is checked or not and ```getDOMValue``` will return the html ```value``` attribute.\n\nEach input component can accept the following properties (in addition to the standard DOM element properties)\n* ***name***: should be used on input components representing the model key the field should be initialized with (and what attribute key to use with modelPopulate).\n* **bind**: ```true``` to initiate 2-way binding (when the input field is updated, the model will be updated to match), ```{validate: true}``` to validate the entire model when the field is updated, ```{validateField: true}``` to validate *just* the updated field","packages":{"Text":{"overview":"A model-aware component that is a very light wrapper around *React.DOM.input*.  The *type* attribute is *text* by default but will be overridden if the *type* property is defined.  This component will initialize with the correct default value from the provided model using the \"name\" property as well as participate in the *modelPopulate* mixin (if the \"ref\" attribute is provided).\n\n\n```javascript\n    var Text = Backbone.input.Text;\n\n    var model = new Backbone.Model({age: 3});\n    ...\n    // assuming a model attribute \"age\" exists\n    // \"ref\" is not required but needed if you will be using modelPopulate;  the value does not matter\n    // \"name\" is required;  that is how the Text component knows what model attribute to use\n    // \"model\" is obviously required\n    <Text ref=\"firstName\" name=\"firstName\" model={model}/>\n```","methods":{}},"TextArea":{"overview":"A model-aware component that is a very light wrapper around *React.DOM.textarea*.  This component will initialize with the correct default value from the provided model using the \"name\" property as well as participate in the *modelPopulate* mixin (if the \"ref\" attribute is provided).\n\n```javascript\n    var TextArea = Backbone.input.TextArea;\n\n    var model = new Backbone.Model({description: 'foo'});\n    ...\n    // assuming a model attribute \"description\" exists\n    // \"ref\" is not required but needed if you will be using modelPopulate;  the value does not matter\n    // \"name\" is required;  that is how the TextArea component knows what model attribute to use\n    // \"model\" is obviously required\n    <TextArea ref=\"description\" name=\"description\" model={model}/>\n```","methods":{}},"CheckBox":{"overview":"A model-aware component that is a very light wrapper around *React.DOM.input* (type=checkbox).  This component will initialize with the correct default value from the provided model using the \"name\" property as well as participate in the *modelPopulate* mixin (if the \"ref\" attribute is provided).  The *value* property is not required (true/false) will be used but if the *value* property is specified, that value will be set on the model in the checked case.\n\n```javascript\n    var CheckBox = Backbone.input.CheckBox;\n\n    var model = new Backbone.Model({acceptTermsOfService: true});\n    ...\n    // assuming a model attribute \"acceptTermsOfService\" exists\n    // \"ref\" is not required but needed if you will be using modelPopulate;  the value does not matter\n    // \"name\" is required;  that is how the CheckBox component knows what model attribute to use\n    // \"model\" is obviously required\n    <CheckBox ref=\"acceptTermsOfService\" name=\"acceptTermsOfService\" model={model}/>\n```","methods":{}},"Select":{"overview":"A model-aware component that is a very light wrapper around *React.DOM.select*.  This component will initialize with the correct default value from the provided model using the \"name\" property as well as participate in the *modelPopulate* mixin (if the \"ref\" attribute is provided).\n\n```javascript\n    var Select = Backbone.input.Select;\n\n    var model = new Backbone.Model({eyeColor: 'green'});\n    ...\n    // assuming a model attribute \"eyeColor\" exists\n    // \"ref\" is not required but needed if you will be using modelPopulate;  the value does not matter\n    // \"name\" is required;  that is how the Select component knows what model attribute to use\n    // \"model\" is obviously required\n    <Select ref=\"eyeColor\" name=\"eyeColor\" model={model}>\n      <option value=\"blue\">blue</option>\n      <option value=\"green\">green</option>\n      <option value=\"brown\">brown</option>\n    </Select>\n```","methods":{}},"RadioGroup":{"overview":"A model-aware component that should contain one or *React.DOM.input* (type=radio).  This component will initialize with the correct default value from the provided model using the \"name\" property as well as participate in the *modelPopulate* mixin (if the \"ref\" attribute is provided).\n\n*note: this component does not create the radio buttons for you - it is only a wrapper for nested content provided by you to expose the functions necessary for getting and setting model values.*\n\n```javascript\n    var RadioGroup = Backbone.input.RadioGroup;\n\n    var model = new Backbone.Model({eyeColor: 'green'});\n    ...\n    // assuming a model attribute \"eyeColor\" exists\n    // \"ref\" is not required but needed if you will be using modelPopulate;  the value does not matter\n    // \"name\" is required;  that is how the RadioGroup component knows what model attribute to use\n    // \"model\" is obviously required\n    <RadioGroup ref=\"eyeColor\" name=\"eyeColor\" model={model}>\n      <input type=\"radio\" value=\"blue\"/> blue\n      <input type=\"radio\" value=\"green\"> green\n      <input type=\"radio\" value=\"brown\"> brown\n    </RadioGroup>\n```","methods":{}}}},"Mixins":{"methods":{},"description":"These mixins can be referenced by their alias (see mixin examples) because they are registered using [jhudson8/react-mixin-manager](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Freact-mixin-manager).","packages":{"modelAware":{"overview":"Utility methods which allows other mixins to depend on the ```getModel``` function.  This provides an single overridable mixin should you have non-standard model population requirements.","methods":{"getModel":{"profiles":["callback"],"params":{"callback":"optional callback (function(model, propName)) for when there are multiple models"},"summary":"The model can be set using the ```model``` property.","dependsOn":[],"overview":"```javascript\n    React.createClass({\n      mixins: ['modelAware'] // or ['react-backbone.modelAware']\n    });\n    ...\n    <MyClass model={model}/>\n    ...\n    // get the single (or first) model bound to this component\n    var model = myClass.getModel();\n```\n\nThere can actually be multiple models bound to a single component.  To access all bound models, a iterator callback method can be provided.\n\n```javascript\n    React.createClass({\n      mixins: ['modelAware(\"foo\", \"bar\")']\n    });\n    ...\n    <MyClass foo={model1} bar={model2}/>\n    ...\n    // iterate all models bound to this component\n    myClass.getModel(function(model, propName) {\n      // will be called twice with (model1, \"foo\") and (model2, \"bar\")\n    });\n```","returns":"the single model associated with the current React component."}}},"collectionAware":{"overview":"Utility methods which allows other mixins to depend on the ```getCollection``` function.  This provides an single overridable mixin should you have non-standard collection population requirements.","methods":{"getCollection":{"profiles":["callback"],"params":{"callback":"optional callback (function(collection, propName)) for when there are multiple collections"},"summary":"The collection can be set using the ```collection``` property.","dependsOn":[],"overview":"```javascript\n    React.createClass({\n      mixins: ['collectionAware'] // or ['react-backbone.collectionAware']\n    });\n    ...\n    <MyClass collection={collection}/>\n    ...\n    // get the single (or first) collection bound to this component\n    var collection = myClass.getCollection();\n```\n\nThere can actually be multiple collections bound to a single component.  To access all bound collections, a iterator callback method can be provided.\n\n```javascript\n    React.createClass({\n      mixins: ['collectionAware(\"foo\", \"bar\")']\n    });\n    ...\n    <MyClass foo={collection1} bar={collection2}/>\n    ...\n    // iterate all collection bound to this component\n    myClass.getCollection(function(model, propName) {\n      // will be called twice with (collection1, \"foo\") and (collection2, \"bar\")\n    });\n```","returns":"the single collection associated with the current React component."},"setCollection":{"profiles":["collection"],"params":{"collection":"the Backbone collection to set"},"summary":"Associate the collection with the current React component which can be retrieved using ```getCollection```.  When using this, all collection event bindings will be automatically transferred to the new collection.","dependsOn":[],"overview":""}}},"modelPopulate":{"overview":"*depends on [modelAware](#link/%23snippet%2Fpackage%2FmodelAware)*\n\nUtility mixin used to iterate child components and have their associated value set on a Backbone.Model.","methods":{"modelPopulate":{"profiles":["[componentArray][, callback][, options][, model]"],"params":{"componentArray":"the array of components to iterate.  If falsy, all child components that contain a ```ref``` attribute will be used","callback":"the callback that will be executed ***only if*** the model passed validation when the attributes were set.  If provided, the model will be set automatically.","options":"the. model set options (Backbone.Model.set options parameter).  Additional an ***onInvalid*** option attribute can be used to be notified if the model failed validation","model":"the model to set the form values on or false if the default component bound model should not be used in favor or just returning the attributes.  If no model is provided the componet's bound model will be used."},"summary":"Iterate all child components with a [ref](#link/http%3A%2F%2Ffacebook.github.io%2Freact%2Fdocs%2Fmore-about-refs.html) property and have each component set it's input value on the model attributes.\nComponents will only participate in model population if they implement ***getValue*** to return the value that should be set on the model.","dependsOn":[],"overview":"If a component does not contain a ```getValue``` method but does contain a ```modelPopulate``` method (by including the ```modelPopulate``` mixin), the modelPopulate method on that component will be called as well with the attributes applied to the parent component's model.\n\nIf it isn't working as expected\n\n* make sure input fields have a ```ref``` attribute (that allows them to participate as fields in population)\n* make sure input fields have a  ```name``` attribute (that is the model attribute association)\n* make sure the component includes the ```modelPopulate``` mixin\n\n\nIf a model is provided, the attributes will be set on it as long as they pass model validation.\n\n```javascript\n    React.create.Class({\n      mixins: ['modelPopulate'], // or ['react-backbone.modelPopulate']\n\n      render: function() {\n        var model = this.props.model;\n\n        return (\n          <form onSubmit={this.onSubmit}>\n            Name:\n            <Text ref=\"name\" name=\"name\" model={model}/>\n            <br/>\n\n            Summary:\n            <TextArea ref=\"summary\" name=\"summary\" model={model}/>\n            <br/>\n\n            Accept Terms and Conditions?:\n            <CheckBox ref=\"acceptTOC\" name=\"acceptTOC\" model={model}/>\n            <br/>\n\n            Hair Color:\n            <Select ref=\"hairColor\" name=\"hairColor\" model={model}>\n              <option value=\"black\">black</option>\n              <option value=\"blonde\">blonde</option>\n              <option value=\"brown\">brown</option>\n            </Select>\n            <br/>\n\n            Eye Color:\n            <RadioGroup ref=\"eyeColor\" name=\"eyeColor\" model={model}>\n              <input type=\"radio\" name=\"eyeColor\" value=\"blue\"/> blue\n              <input type=\"radio\" name=\"eyeColor\" value=\"brown\"/> brown\n              <input type=\"radio\" name=\"eyeColor\" value=\"green\"/> green\n            </RadioGroup>\n            <br/>\n\n            <button>Submit</button>\n          </form>\n        );\n      },\n      onFormSubmit: function() {\n        // use this.refs automatically to get the components that will populate the model\n        this.modelPopulate(function(model) {\n          // if the model validation passed, this callback will be executed\n        }, {\n          onInvalid: function(attributes) {\n            // these attributes did not pass model validation\n          }\n        });\n\n        // or for more control\n        var attributes = this.modelPopulate();\n\n        // or for even more control\n        var attributes = this.modelPopulate(specificComponentsToCheck);\n      }\n    });\n```","returns":"the attribute values"}}},"modelFetch":{"overview":"Mixin which will ensure any bound model(s) has been fetched (but will not initiate a fetch if a fetch is in progress or the model(s) has already been fetched).\n\n```javascript\n    React.createClass({\n      mixins: ['modelFetch'] // or ['react-backbone.modelFetch']\n    });\n    ...\n\n    // model.fetch will be called when the component is mounted\n    <MyClass model={model}/>\n```","methods":{}},"collectionFetch":{"overview":"Mixin which will ensure any bound collection(s) has been fetched (but will not initiate a fetch if a fetch is in progress or the collection(s) has already been fetched).\n\n```javascript\n    React.createClass({\n      mixins: ['collectionFetch'] // or ['react-backbone.collectionFetch']\n    });\n    ...\n\n    // collection.fetch will be called when the component is mounted\n    <MyClass collection={collection}/>\n```","methods":{}},"modelEvents":{"overview":"*depends on [modelAware](#link/%23snippet%2Fpackage%2FmodelAware), [listen](#link/%23snippet%2Fpackage%2Flisten), [events](#link/%23snippet%2Fpackage%2Fevents)*\n\nUtility mixin to support declarative model event bindings as well as expose managed model binding functions which are cleaned up when the component is unmounted.\n\nThis mixin should be included (instead of the \"events\" mixin) if any declarative model event bindings are used.\n\n```javascript\n    var MyClass React.createClass({\n      mixins: ['modelEvents'], // or ['react-backbone.modelEvents']\n\n      events: {\n        'model:foo': 'onFoo',\n        model: {\n          bar: 'onBar'\n        }\n      },\n      onFoo: function() { ... },\n      onBar: function() { ... }\n    });\n```","methods":{"modelOn":{"profiles":["eventName, callback[, context]"],"params":{"eventName":"the event name","callback":"the event callback function","context":"the callback context"},"summary":"Equivalent to Backbone.Events.on but will be unbound when the component is unmounted.  Also similar to the \"listenTo\" method except that if the model is changed, the previous model bindings will be removed and the new model will have the bindings applied.","dependsOn":[],"overview":"```javascript\n    var MyClass React.createClass({\n      mixins: ['modelEvents'], // or ['react-backbone.modelEvents']\n\n      getInitialState: function() {\n        this.modelOn('change', this.onChange);\n        return null;\n      },\n      onChange: function() { ... }\n    });\n```"},"modelOnce":{"profiles":["eventName, callback[, context]"],"params":{"eventName":"the event name","callback":"the event callback function","context":"the callback context"},"summary":"Equivalent to Backbone.Events.once but will be unbound when the component is unmounted.  Also similar to the \"listenToOnce\" method except that if the model is changed, the previous model bindings will be removed and the new model will have the bindings applied.","dependsOn":[],"overview":"```javascript\n    var MyClass React.createClass({\n      mixins: ['modelEvents'], // or ['react-backbone.modelEvents']\n\n      getInitialState: function() {\n        this.modelOnce('change', this.onChange);\n        return null;\n      },\n      onChange: function() { ... }\n    });\n```"},"modelOff":{"profiles":["eventName, callback[, context]"],"params":{"eventName":"the event name","callback":"the event callback function","context":"the callback context"},"summary":"Remove the provided modelOn / modelOnce event bindings.","dependsOn":[],"overview":""}}},"collectionEvents":{"overview":"*depends on [collectionAware](#link/%23snippet%2Fpackage%2FcollectionAware), [listen](#link/%23snippet%2Fpackage%2Flisten), [events](#link/%23snippet%2Fpackage%2Fevents)*\n\nUtility mixin to support declarative collection event bindings as well as expose managed collection binding functions which are cleaned up when the component is unmounted.\n\nThis mixin should be included (instead of the \"events\" mixin) if any declarative collection event bindings are used.\n\n```javascript\n    var MyClass React.createClass({\n      mixins: ['collectionEvents'], // or ['react-backbone.collectionEvents']\n\n      events: {\n        'collection:foo': 'onFoo',\n        collection: {\n          bar: onBar\n        }\n      },\n      onFoo: function() { ... },\n      onBar: function() { ... }\n    });\n```","methods":{"collectionOn":{"profiles":["eventName, callback[, context]"],"params":{"eventName":"the event name","callback":"the event callback function","context":"the callback context"},"summary":"Equivalent to Backbone.Events.on but will be unbound when the component is unmounted.  Also similar to the \"listenTo\" method except that if the collection is changed, the previous collection bindings will be removed and the new collection will have the bindings applied.","dependsOn":[],"overview":"```javascript\n    var MyClass React.createClass({\n      mixins: ['collectionEvents'], // or ['react-backbone.collectionEvents']\n\n      getInitialState: function() {\n        this.collectionOn('reset', this.onReset);\n        return null;\n      },\n      onReset: function() { ... }\n    });\n```"},"collectionOnce":{"profiles":["eventName, callback[, context]"],"params":{"eventName":"the event name","callback":"the event callback function","context":"the callback context"},"summary":"Equivalent to Backbone.Events.once but will be unbound when the component is unmounted.  Also similar to the \"listenToOnce\" method except that if the collection is changed, the previous model bindings will be removed and the new collection will have the bindings applied.","dependsOn":[],"overview":"```javascript\n    var MyClass React.createClass({\n      mixins: ['collectionEvents'], // or ['react-backbone.collectionEvents']\n\n      getInitialState: function() {\n        this.collectionOnce('reset', this.onReset);\n        return null;\n      },\n      onReset: function() { ... }\n    });\n```"},"collectionOff":{"profiles":["eventName, callback[, context]"],"params":{"eventName":"the event name","callback":"the event callback function","context":"the callback context"},"summary":"Remove the provided collectionOn / collectionOnce event bindings.","dependsOn":[],"overview":""}}},"modelValidator":{"overview":"*depends on [modelAware](#link/%23snippet%2Fpackage%2FmodelAware)*","methods":{"modelValidate":{"profiles":["attributes, options"],"params":{"attributes":"the model attributes","options":"the set options"},"summary":"","dependsOn":[],"overview":"","returns":"the response from the model's validate method (transformed with React.mixins.modelIndexErrors)"}}},"modelInvalidAware":{"overview":"*depends on [modelEvents](#link/%23snippet%2Fpackage%2FmodelEvents)*\n\nAllow components to be aware of field specific validation errors.  The ```name``` property must be provide to tell this mixin which model attribute to listen to for ```invalid``` events.  When the event is triggered, the ```invalid``` state attribute will be set as the error message provided to the ```invalid``` event.  The state will not be unset by this mixin (as there is no ```valid``` model event).\n\nIf it isn't working as expected\n\n* make sure the component has a ```name``` attribute (that allows them to listen for the invalid event)\n* make sure the component includes the ```modelInvalidAware``` mixin\n\nWhen these occur, normalize the error payload using ```React.mixins.modelIndexErrors```.\n\n```javascript\n    var MyClass React.createClass({\n      mixins: ['modelInvalidAware'], // or ['react-backbone.modelInvalidAware']\n\n      render: function() {\n        var invalidMessage = this.state.invalid;\n        if (invalidMessage) {\n          return 'Error: ' + error;\n        } else {\n          return 'No error';\n        }\n      }\n    });\n```","methods":{}},"backboneChangeAware":{"overview":"Convienance mixin to include the [modelChangeAware](#link/%23snippet%2Fpackage%2FmodelChangeAware) and [collectionChangeAware](#link/%23snippet%2Fpackage%2FcollectionChangeAware) mixins.  Refer to those mixins for more details.","methods":{}},"modelChangeAware":{"overview":"*depends on [modelEvents](#link/%23snippet%2Fpackage%2FmodelEvents)*\n\nWill force a render if the associated model fires the \"change\" event.\nIf you want to force a render only on specific model events, see [modelUpdateOn](#link/%23snippet%2Fpackage%2FmodelUpdateOn).\n\n```javascript\n    var MyClass React.createClass({\n      mixins: ['modelChangeAware'], // or ['react-backbone.modelChangeAware']\n\n      render: function() {\n        // will be executed if the associated model changes\n      }\n    });\n```\n\n*multiple models can be associated with the component for change-awareness.  see [multiple models/components](#link/%23section%2FMultiple%2520models%2520and%2520collections)*","methods":{}},"collectionChangeAware":{"overview":"*depends on [collectionEvents](#link/%23snippet%2Fpackage%2FcollectionEvents)*\n\nWill force a render if the associated collection fires the \"reset\", \"add\", \"remove\" or \"sort\" event.\nIf you want to force a render only on specific collection events, see [collectionUpdateOn](#link/%23snippet%2Fpackage%2FcollectionUpdateOn).\n\n```javascript\n    var MyClass React.createClass({\n      mixins: ['collectionChangeAware'], // or ['react-backbone.collectionChangeAware']\n\n      render: function() {\n        // will be executed if the associated model changes\n      }\n    });\n```\n\n*multiple collections can be associated with the component for change-awareness.  see [multiple models/components](#link/%23section%2FMultiple%2520models%2520and%2520collections)*","methods":{}},"backboneUpdateOn":{"overview":"Convienance mixin to include the [modelUpdateOn](#link/%23snippet%2Fpackage%2FmodelUpdateOn) and [collectionUpdateOn](#link/%23snippet%2Fpackage%2FcollectionUpdateOn) mixins.  Refer to those mixins for more details.","methods":{}},"modelUpdateOn":{"overview":"*depends on [modelEvents](#link/%23snippet%2Fpackage%2FmodelEvents)*\n\nListen to a specific event (or array of events).  When this event is fired, the component will be force updated.  The events to listen for are defined as the ```updateOn``` component property which can be a string or array of strings.  In addition, the declaring component can define the keys using parameters (see examples);\n\n*when a parent component provides the event name(s) as the ```updateOn``` parameter*\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['modelUpdateOn'], // or ['react-backbone.modelUpdateOn']\n      ...\n    });\n    ...\n    <MyComponent updateOn=\"foo\" model={myModel}/>\n    // or\n    <MyComponent updateOn{['foo', 'bar']} model={myModel}/>\n```\n\n* when the child/declaring component provides the event name(s) as mixin parameters*\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['modelUpdateOn(\"foo\", \"bar\")'], // or ['react-backbone.modelUpdateOn(\"foo\", \"bar\")']\n      ...\n    });\n\n    // equivalent to\n\n    var MyComponent = React.createClass({\n      mixins: ['modelEvents'],\n\n      events: {\n        model: {\n          foo: 'forceUpdate',\n          bar: 'forceUpdate'\n        }\n      }\n      ...\n    });\n```","methods":{}},"collectionUpdateOn":{"overview":"*depends on [modelEvents](#link/%23snippet%2Fpackage%2FmodelEvents)*\n\nListen to a specific event (or array of events).  When this event is fired, the component will be force updated.  The events to listen for are defined as the ```updateOn``` component property which can be a string or array of strings.  In addition, the declaring component can define the keys using parameters (see examples);\n\n*when a parent component provides the event name(s) as the ```updateOn``` parameter*\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['collectionUpdateOn'], // or ['react-backbone.collectionUpdateOn']\n      ...\n    });\n    ...\n    <MyComponent updateOn=\"foo\" collection={myCollection}/>\n    // or\n    <MyComponent updateOn{['foo', 'bar']} collection={myCollection}/>\n```\n\n* when the child/declaring component provides the event name(s) as mixin parameters*\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['collectionUpdateOn(\"foo\", \"bar\")'], // or ['react-backbone.collectionUpdateOn(\"foo\", \"bar\")']\n      ...\n    });\n\n    // equivalent to\n\n    var MyComponent = React.createClass({\n      mixins: ['collectionEvents'], // or ['react-backbone.collectionEvents']\n\n      events: {\n        collection: {\n          foo: 'forceUpdate',\n          bar: 'forceUpdate'\n        }\n      }\n      ...\n    });\n```","methods":{}},"backboneLoadOn":{"overview":"Convienance mixin to include the [modelLoadOn](#link/%23snippet%2Fpackage%2FmodelLoadOn) and [collectionLoadOn](#link/%23snippet%2Fpackage%2FcollectionLoadOn) mixins.  Refer to those mixins for more details.","methods":{}},"modelLoadOn":{"overview":"*depends on [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events), [modelEvents](#link/%23snippet%2Fpackage%2FmodelEvents)*\n\nGives any comonent the ability to listen to a specific async event(s).\n\nSee the docs in [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events) for more details on the async events.\n\nWhen this event is fired, the state attribute ```loading``` will be set to ```true```.  state.loading will be set to false when the async event is complete.\n\nUse the ```loadOn``` property to define the specific async event name to bind to.  In addition, the declaring component can define the event names using parameters (see examples).\n\nWhen the XHR event name(s) are dynamically provded as as the ```modelLoadOn``` parameter\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['modelLoadOn'], // or ['react-backbone.modelLoadOn']\n\n      render: function() {\n        if (this.state.loading) {\n          ...\n        } else {\n          ...\n        }\n      }\n    });\n    ...\n    <MyComponent loadOn=\"read\" model={myModel}/>\n    // or\n    <MyComponent loadOn={['read', 'update']} model={myModel}/>\n```\n\nWhen the XHR event name(s) are statically defined by the owning component\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['modelLoadOn(\"read\", \"update\")'], // or ['react-backbone.modelLoadOn(\"read\", \"update\")']\n      ...\n    });\n```\n\nFor more details on all XHR events [look here](#link/http%3A%2F%2Fjhudson8.github.io%2Ffancydocs%2Findex.html%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Fbackbone-xhr-events%2Fsection%2FXHR%2520Method%2520Reference%3Ffocus%3Doutline)","methods":{}},"collectionLoadOn":{"overview":"*depends on [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events), [collectionEvents](#link/%23snippet%2Fpackage%2FcollectionEvents)*\n\nGives any comonent the ability to listen to a specific async event(s).\n\nSee the docs in [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events) for more details on the async events.\n\nWhen this event is fired, the state attribute ```loading``` will be set to ```true```.  state.loading will be set to false when the async event is complete.\n\nUse the ```loadOn``` property to define the specific async event name to bind to.  In addition, the declaring component can define the event names using parameters (see examples).\n\nWhen the XHR event name(s) are dynamically provded as as the ```modelLoadOn``` parameter\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['collectionLoadOn'], // or ['react-backbone.collectionLoadOn']\n\n      render: function() {\n        if (this.state.loading) {\n          ...\n        } else {\n          ...\n        }\n      }\n    });\n    ...\n    <MyComponent loadOn=\"read\" collection={myCollection}/>\n    // or\n    <MyComponent loadOn={['read', 'update']} collection={myCollection}/>\n```\n\nWhen the XHR event name(s) are statically defined by the owning component\n\n```javascript\n    var MyComponent = React.createClass({\n      mixins: ['collectionLoadOn(\"read\", \"update\")'], // or ['react-backbone.collectionLoadOn(\"read\", \"update\")']\n      ...\n    })\n```\n\nFor more details on all XHR events [look here](#link/http%3A%2F%2Fjhudson8.github.io%2Ffancydocs%2Findex.html%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Fbackbone-xhr-events%2Fsection%2FXHR%2520Method%2520Reference%3Ffocus%3Doutline)","methods":{}},"loadWhile":{"overview":"","methods":{"loadWhile":{"profiles":["callback[, loadingStateAttribute]"],"params":{"callback":"the function that will be executed containing any XHR activity to be monitored","loadingStateAttribute":"the attribute (\"loading\" if not provided) to reference the loading state"},"summary":"Set the component state attribute (\"loading\" or loadingStateAttribute if provided) to a truthy value while *any* XHR activity is in progress as long as it was initiated during the execution of the callback function.","dependsOn":[],"overview":"```javascript\n    React.createComponent({\n      mixins: ['loadWhile'],\n\n      doSomething: function() {\n        this.loadWhile(function() {\n          // the \"loading\" attribute will be truthy as long as any of these fetches are in progress\n          this.props.collection1.fetch();\n          this.props.collection2.fetch();\n          this.props.collection3.fetch();\n        });\n      }\n    });\n```"}}},"backboneXHRAware":{"overview":"Convienance mixin to include the [modelXHRAware](#link/%23snippet%2Fpackage%2FmodelXHRAware) and [collectionXHRAware](#link/%23snippet%2Fpackage%2FcollectionXHRAware) mixins.  Refer to those mixins for more details.","methods":{}},"modelXHRAware":{"overview":"*depends on [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events), [modelEvents](#link/%23snippet%2Fpackage%2FmodelEvents)*\n\nGives any comonent the ability to listen to ***all*** async events.\n\nSee the docs in [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events) for more details on the async events.\n\nWhen ***any*** XHR event is fired, the state attribute ```loading``` will be set to a truthy value.  state.loading will be set to a falsy value when the XHR activity is complete.\n\n```javascript\n    React.createClass({\n      mixins: ['modelXHRAware'], // or ['react-backbone.modelXHRAware']\n\n      render: function() {\n        if (this.state.loading) {\n          // return something if we are loading\n        } else {\n          // return something if we are not loading\n        }\n      }\n    });\n```\n\nYou can optional provide an object argument to the mixin allowing you to specificy individual mixin events and overriding the loading state attribute.  The key for each entry is the XHR event type and the value is the state attribute to indicate the loading activity.  For example:\n\n```javascript\n    React.createClass({\n      mixins: ['modelXHRAware({read: \"fetching\"})'],\n```\nWill only listen for ```read``` events (fetch) and will use ```state.fetching``` instead of the standard ```state.loading```.\n\nFor more details on all XHR events [look here](#link/http%3A%2F%2Fjhudson8.github.io%2Ffancydocs%2Findex.html%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Fbackbone-xhr-events%2Fsection%2FXHR%2520Method%2520Reference%3Ffocus%3Doutline)\n\n*multiple models can be associated with the component for xhr-awareness.  see [multiple models/components](#link/%23section%2FMultiple%2520models%2520and%2520collections)*","methods":{}},"collectionXHRAware":{"overview":"*depends on [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events), [collectionEvents](#link/%23snippet%2Fpackage%2FcollectionEvents)*\n\nGives any comonent the ability to listen to ***all*** async events.\n\nSee the docs in [jhudson8/backbone-xhr-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Fbackbone-xhr-events) for more details on the async events.\n\nWhen ***any*** XHR event is fired, the state attribute ```loading``` will be set to a truthy value.  state.loading will be set to a falsy value when the XHR activity is complete.\n\n```javascript\n    React.createClass({\n      mixins: ['collectionXHRAware'], // or ['react-backbone.collectionXHRAware']\n\n      render: function() {\n        if (this.state.loading) {\n          // return something if we are loading\n        } else {\n          // return something if we are not loading\n        }\n      }\n    });\n```\n\nYou can optional provide an object argument to the mixin allowing you to specificy individual mixin events and overriding the loading state attribute.  The key for each entry is the XHR event type and the value is the state attribute to indicate the loading activity.  For example:\n\n```javascript\n    React.createClass({\n      mixins: ['collectionXHRAware({read: \"fetching\"})'],\n```\nWill only listen for ```read``` events (fetch) and will use ```state.fetching``` instead of the standard ```state.loading```.\n\nFor more details on all XHR events [look here](#link/http%3A%2F%2Fjhudson8.github.io%2Ffancydocs%2Findex.html%23project%2Fjhudson8%2Freact-backbone%2Fbundle%2Fjhudson8%2Fbackbone-xhr-events%2Fsection%2FXHR%2520Method%2520Reference%3Ffocus%3Doutline)\n\n*multiple collections can be associated with the component for xhr-awareness.  see [multiple models/components](#link/%23section%2FMultiple%2520models%2520and%2520collections)*","methods":{}}}},"Event Binding Definitions":{"methods":{},"description":"Event listeners can be declared using the ```events``` attribute.  To add this support the ```events``` mixin ***must*** be included with your component mixins.  see [react-events](#link/https%3A%2F%2Fgithub.com%2Fjhudson8%2Freact-events) for details","packages":{"model events":{"overview":"In addition to providing mixins which give Backbone awareness to React components, declaritive model events are made available similar to the ```events``` hash in Backbone.View.\n\nModel events can be defined using the ```model:``` prefix.\n\nFor example, by including the ```events``` mixin, you can do this:\n\n```javascript\n    React.createClass({\n      mixins: ['modelEvents'], // or ['react-backbone.modelEvents']\n\n      events: {\n        'model:event1': 'onEvent1',\n        model: {\n          event2: 'onEvent2',\n          event3: function() { ... }\n        }\n      },\n      onEvent1: ...,\n      onEvent2: ...\n    });\n```\n\nAnd the model that is bound to the component (using the ```model``` property) will have ```event1```, ```event2``` and ```event3``` bound to the associated component functions.","methods":{}},"collection events":{"overview":"In addition to providing mixins which give Backbone awareness to React components, declaritive collection events are made available similar to the ```events``` hash in Backbone.View.\n\nCollection events can be defined using the ```collection:``` prefix.\n\nFor example, by including the ```events``` mixin, you can do this:\n\n```javascript\n    React.createClass({\n      mixins: ['collectionEvents'], // or ['react-backbone.collectionEvents']\n\n      events: {\n        'collection:event1': 'onEvent1',\n        collection: {\n          event2: 'onEvent2',\n          event3: function() { ... }\n        }\n      },\n      onEvent1: ...,\n      onEvent2: ...\n    });\n```\n\nAnd the collection that is bound to the component (using the ```collection``` property) will have ```event1```, ```event2``` and ```event3``` bound to the associated component functions.","methods":{}},"*memoize":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nMemoizes a given function by caching the computed result.  see [_.memoize](#link/http%3A%2F%2Funderscorejs.org%2F%23memoize) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*memoize()->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*delay":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nInvokes function after wait millisecond.  see [_.delay](#link/http%3A%2F%2Funderscorejs.org%2F%23delay) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*delay(1000)->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*defer":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nDefers invoking the function until the current call stack has cleared.  see [_.defer](#link/http%3A%2F%2Funderscorejs.org%2F%23defer) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*defer()->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*throttle":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nCreates and returns a new, throttled version of the passed function, that, when invoked repeatedly, will only actually call the original function at most once per every wait milliseconds.  see [_.throttle](#link/http%3A%2F%2Funderscorejs.org%2F%23throttle) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*throttle(1000)->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*debounce":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nCreates and returns a new debounced version of the passed function which will postpone its execution until after wait milliseconds have elapsed since the last time it was invoked.  see [_.debounce](#link/http%3A%2F%2Funderscorejs.org%2F%23debounce) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*debounce(1000)->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*once":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nCreates a version of the function that can only be called one time. Repeated calls to the modified function will have no effect, returning the value from the original call.  see [_.once](#link/http%3A%2F%2Funderscorejs.org%2F%23once) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*once()->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*after":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nCreates a version of the function that will only be run after first being called count times.  see [_.after](#link/http%3A%2F%2Funderscorejs.org%2F%23after) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*after(3)->window:resize': 'onWindowResize'\n    }\n```","methods":{}},"*before":{"overview":"*include the [events](#link/%23snippet%2Fpackage%2Fevents) mixin*\n\nCreates a version of the function that can be called no more than count times.  see [_.before](#link/http%3A%2F%2Funderscorejs.org%2F%23before) for more details\n\n```javascript\n    mixins: ['events'],\n    events: {\n      '*before(3)->window:resize': 'onWindowResize'\n    }\n```","methods":{}}}},"API":{"methods":{},"packages":{"React.mixins":{"overview":"","methods":{"getModelKey":{"profiles":["component"],"params":{"component":"The ReactComponent that is associated with the model key specific property"},"summary":"Return the model key name associated with a component.  While this can be overridden to sute your needs, the default impl is as follows:","dependsOn":[],"overview":"```javascript\n    if (reactComponent.getModelKey) {\n      return component.getModelKey();\n    }\n    return component.props.name || component.props.key || component.props.ref;\n```"},"modelIndexErrors":{"profiles":["errors, component"],"params":{"errors":"the error payload from a model validation"},"summary":"Return the errors in a standardized format.  This can be overridden to suire your needs.  The default implementation will take errors in an array","dependsOn":[],"overview":"```javascript\n    [{field1Key: message}, {field2Key: message}, ...]\n```\n\nto a single object\n\n```javascript\n    { field1Key: errorMessage, field2Key: errorMessage, ... }\n```"}}}}}}});
